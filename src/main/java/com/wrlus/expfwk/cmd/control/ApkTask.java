package com.wrlus.expfwk.cmd.control;

import android.Manifest;
import com.wrlus.expfwk.env.Env;
import android.content.Context;
import android.content.IIntentReceiver;
import android.content.IIntentSender;
import android.content.Intent;
import android.content.IntentSender;
import android.content.pm.PackageInstaller;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.IBinder;

import com.wrlus.expfwk.utils.LogUtil;
import com.wrlus.expfwk.cmd.Task;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class ApkTask extends Task {
    private static final String TAG = "InstallApkTask";
    private final String params;

    public ApkTask(String params) {
        this.params = params;
    }

    @Override
    public void doTask() {
        String apkPath = "base.apk";
        if (!params.trim().equals("")) {
            apkPath = params;
        }
        Context context = Env.getSystemContext();
        if (context == null) {
            LogUtil.e(TAG, "Context is null.");
            return;
        }
        if (context.checkSelfPermission(Manifest.permission.INSTALL_PACKAGES)
                != PackageManager.PERMISSION_GRANTED) {
            LogUtil.w(TAG, "No INSTALL_PACKAGES permission, InstallApkTask maybe failed.");
        }
        installNewApk(context, apkPath);
    }

    private void installNewApk(Context context, String apkPath) {
        install(context, apkPath, PackageInstaller.SessionParams.MODE_FULL_INSTALL);
    }

    private void updateExistApk(Context context, String apkPath) {
        install(context, apkPath, PackageInstaller.SessionParams.MODE_INHERIT_EXISTING);
    }

    private void install(Context context, String apkPath, int mode) {
        if (!apkPath.endsWith(".apk")) {
            LogUtil.e(TAG, "APK file name must end with .apk");
            return;
        }
        String apkName = apkPath.substring(apkPath.lastIndexOf(File.separator) + 1,
                apkPath.lastIndexOf(".apk"));
        PackageInstaller packageInstaller = context.getPackageManager().getPackageInstaller();
        PackageInstaller.SessionParams sessionParams =
                new PackageInstaller.SessionParams(mode);
        try {
            int sessionId = packageInstaller.createSession(sessionParams);
            PackageInstaller.Session session = packageInstaller.openSession(sessionId);
            OutputStream os = session.openWrite(apkName, 0, -1);
            FileInputStream fis = new FileInputStream(apkPath);
            byte[] buffer = new byte[4096];
            for (int n; (n = fis.read(buffer)) > 0;) {
                os.write(buffer, 0, n);
            }
            fis.close();
            os.flush();
            os.close();
            final LocalIntentReceiver receiver = new LocalIntentReceiver();
            session.commit(receiver.getIntentSender());
            Intent result = receiver.getResult();
            String failReason = "Unknown Reason";
            if (result != null) {
                int status = result.getIntExtra(PackageInstaller.EXTRA_STATUS,
                        PackageInstaller.STATUS_FAILURE);
                failReason = result.getStringExtra(PackageInstaller.EXTRA_STATUS_MESSAGE);
                if (status == PackageInstaller.STATUS_SUCCESS) {
                    LogUtil.i(TAG, "Success");
                    return;
                }
            }
            LogUtil.e(TAG, "Failure ["+ failReason + "]");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // frameworks/base/services/core/java/com/android/server/pm/PackageManagerShellCommand.java
    private static class LocalIntentReceiver {
        private final LinkedBlockingQueue<Intent> mResult = new LinkedBlockingQueue<>();
        private final IBinder mLocalSender = new IIntentSender.Stub() {
            @Override
            public void send(int code, Intent intent, String resolvedType,
                             IBinder whitelistToken, IIntentReceiver finishedReceiver,
                             String requiredPermission, Bundle options) {
                try {
                    mResult.offer(intent, 5, TimeUnit.SECONDS);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };

        public IntentSender getIntentSender() {
            return new IntentSender(mLocalSender);
        }

        public Intent getResult() {
            try {
                return mResult.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return null;
        }
    }
}
