package com.wrlus.expfwk.cmd.control;

import android.Manifest;
import android.content.Context;
import android.content.IIntentReceiver;
import android.content.IIntentSender;
import android.content.Intent;
import android.content.IntentSender;
import android.content.pm.PackageInstaller;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.IBinder;

import com.wrlus.expfwk.utils.ContextUtil;
import com.wrlus.expfwk.utils.LogUtil;
import com.wrlus.expfwk.cmd.Task;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Constructor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import org.json.JSONException;
import org.json.JSONObject;

public class ApkTask extends Task {
    private static final String TAG = "InstallApkTask";
    private final JSONObject params;

    public ApkTask(JSONObject params) {
        this.params = params;
    }

    @Override
    public void doTask() {
        String apkPath = "./base.apk";
        if (params == null || !params.has("default")) {
            LogUtil.w(TAG, "No apkPath specified, use default ./base.apk.");
        } else if (params.has("default")) {
            try {
                apkPath = params.getString("default");
            } catch (JSONException ignored) {}
        }
        Context context = ContextUtil.getSystemContext();
        if (context.checkSelfPermission(Manifest.permission.INSTALL_PACKAGES)
                != PackageManager.PERMISSION_GRANTED) {
            LogUtil.w(TAG, "No INSTALL_PACKAGES permission, InstallApkTask maybe failed.");
        }
        installNewApk(context, apkPath);
    }

    private void installNewApk(Context context, String apkPath) {
        install(context, apkPath, PackageInstaller.SessionParams.MODE_FULL_INSTALL);
    }

    private void updateExistApk(Context context, String apkPath) {
        install(context, apkPath, PackageInstaller.SessionParams.MODE_INHERIT_EXISTING);
    }

    private void install(Context context, String apkPath, int mode) {
        if (!apkPath.endsWith(".apk")) {
            LogUtil.e(TAG, "APK file name must end with .apk");
            return;
        }
        String apkName = apkPath.substring(apkPath.lastIndexOf(File.separator) + 1,
                apkPath.lastIndexOf(".apk"));
        PackageInstaller packageInstaller = context.getPackageManager().getPackageInstaller();
        PackageInstaller.SessionParams sessionParams =
                new PackageInstaller.SessionParams(mode);
        try {
            int sessionId = packageInstaller.createSession(sessionParams);
            PackageInstaller.Session session = packageInstaller.openSession(sessionId);
            OutputStream os = session.openWrite(apkName, 0, -1);
            FileInputStream fis = new FileInputStream(apkPath);
            byte[] buffer = new byte[4096];
            for (int n; (n = fis.read(buffer)) > 0;) {
                os.write(buffer, 0, n);
            }
            fis.close();
            os.flush();
            os.close();
            final LocalIntentReceiver receiver = new LocalIntentReceiver();
            session.commit(receiver.getIntentSender());
            Intent result = receiver.getResult();
            int status = result.getIntExtra(PackageInstaller.EXTRA_STATUS,
                    PackageInstaller.STATUS_FAILURE);
            if (status == PackageInstaller.STATUS_SUCCESS) {
                LogUtil.i(TAG, "Success");
            } else {
                LogUtil.e(TAG, "Failure ["+
                        result.getStringExtra(PackageInstaller.EXTRA_STATUS_MESSAGE) + "]");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // frameworks/base/services/core/java/com/android/server/pm/PackageManagerShellCommand.java
    private static class LocalIntentReceiver {
        private final LinkedBlockingQueue<Intent> mResult = new LinkedBlockingQueue<>();
        private final IBinder mLocalSender = new IIntentSender.Stub() {
            @Override
            public void send(int code, Intent intent, String resolvedType,
                             IBinder whitelistToken, IIntentReceiver finishedReceiver,
                             String requiredPermission, Bundle options) {
                try {
                    mResult.offer(intent, 5, TimeUnit.SECONDS);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };

        public IntentSender getIntentSender() {
            try {
                Constructor<IntentSender> constructor =
                        IntentSender.class.getDeclaredConstructor(IBinder.class);
                return constructor.newInstance(mLocalSender);
            } catch (ReflectiveOperationException e) {
                e.printStackTrace();
            }
            return null;
        }

        public Intent getResult() {
            try {
                return mResult.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return null;
        }
    }
}
